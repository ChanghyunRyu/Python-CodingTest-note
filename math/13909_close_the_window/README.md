## 13909번 창문 닫기

---

시간 제한: 1초, 메모리 제한: 64MB

서강대학교 컴퓨터공학과 실습실 R912호에는 현재 N개의 창문이 있고 또 N명의 사람이 있다. 
첫 번째 사람은 1의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다.  
2번째 사람은 2의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다. 
이러한 행동을 N번째 사람까지 진행한 후 열려 있는 창문의 개수를 구하라. 
단, 처음에 모든 창문은 닫혀 있다.

예를 들어 현재 3개의 창문이 있고 3명의 사람이 있을 때,

1. 1번째 사람은 1의 배수인 1,2,3번 창문을 연다. (1, 1, 1)
2. 2번째 사람은 2의 배수인 2번 창문을 닫는다. (1, 0, 1)
3. 3번째 사람은 3의 배수인 3번 창문을 닫는다. (1, 0, 0)

결과적으로 마지막에 열려 있는 창문의 개수는 1개 이다.

### 입력

- 첫 번째 줄에는 창문의 개수와 사람의 수 N(1 ≤ N ≤ 2,100,000,000)이 주어진다.

### 출력

- 마지막에 열려 있는 창문의 개수를 출력한다.

---
문제를 흩어보면 결국 마지막에 열리는 창문은 약수의 개수가 홀수인 경우이다.  
그럼 아래처럼 단순하게 숫자의 약수를 구해서 약수의 개수가 홀수인지 판단하면 정답을 구할 수 있다.

물론 입력의 범위를 보면 알겠지만 시간초과가 나온다.
~~~
def find_divisor_num(number):
    if number == 1:
        return 1
    end = int(number*0.5)
    answer = 2
    for i in range(2, end+1):
        if number % i == 0:
            answer += 1
    return answer


n = int(input())
result = 0
for num in range(1, n+1):
    if find_divisor_num(num) % 2 != 0:
        result += 1
print(result)

~~~
다르게 생각해보아야 한다. 숫자 24를 예로 들어보겠다.  
숫자 24를 다음과 같이 표기할 수 있다.
1. 1 x 24
2. 2 x 12
3. 3 x 8
4. 4 x 6

위에서 보면 알겠지만 보통 어떤 수의 약수는 대응하는 다른 약수가 존재한다.  
즉, 보통 약수의 개수는 짝수인 것이다. 그럼 약수의 개수가 홀수인 숫자들은 무엇이 있을지 생각해본다.  
숫자 9를 방금과 똑같이 표기해보겠다
1. 1 x 9
2. 3 x 3

보면 알겠지만 제곱수는 대응하는 다른 약수가 자기 자신이므로 약수의 총 개수가 홀수개가 되는 것이다.   
결국 정답은 범위내의 특정 수의 제곱수를 개수를 의미한다.
~~~
def find_window(number):
    num = 1
    answer = 0
    while num*num <= number:
        answer += 1
        num += 1
    return answer


n = int(input())
print(find_window(n))

~~~

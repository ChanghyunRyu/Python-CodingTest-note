## 보석 도둑

-----

[백준 1202번] 세계적인 도둑 상덕이는 보석점을 털기로 결심했다.

상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.

상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.

### 입력

- 첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)
- 다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi ≤ 1,000,000)
- 다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci ≤ 100,000,000)
- 모든 숫자는 양의 정수이다.

### 출력

- 첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.

-----

### 풀이

내 기준으로 많이 어려웠던 문제로 아이디어가 어렴풋이 짐작이 가지만 구현을 어떻게 해야할지 짐작을 못 해서 풀지 못 한 문제이다.  

특히 반례를 생각하지 못하여 문제 풀이에 난항을 겪었다.  
예를 들어  
보석 = [(1, 20), (2, 100), (5, 50)  
가방 = [10, 2]  
있다고 하면 대충 코드를 작성하게 되면(집어넣는 순서를 제대로 고려하지 않으면) 정답인 150이 아닌 120이 나오게 된다.

일단 가방은 오름차순으로 정렬되어 있다고 하자. 이럴 경우, 배열의 앞쪽에 있는 가방에 담을 수 있는 보석은 무조건 배열의 뒤쪽에 있는 가방에도 담을 수 있다. 뒤로 갈수록 가방의 무게가 늘어나기 때문이다. 

가방마다 넣을 수 있는 모든 보석을 찾아내 가치를 기준으로 한 최대힙(tmp)에 집어넣는다. 위에서 말한대로 앞선 가방에 들어갈 수 있는 보석은 뒤의 가방에도 들어갈 수 있으므로 해당 보석은 리스트에서 삭제한다. 보석 보석에 대해 가방에 들어갈 수 있는지 검사했으면 그 중 가장 가치가 큰 보석을 결과에 더해준다.

~~~
import sys
import heapq

n, k = map(int, input().split())

jewel = []
for _ in range(n):
    m, v = map(int, sys.stdin.readline().split())
    jewel.append((m, v))

backpack = []
for _ in range(k):
    backpack.append(int(sys.stdin.readline()))

jewel.sort(key=lambda x: (x[0], -x[1]))
backpack.sort()

result = 0
tmp = []

for b in backpack:
    while jewel and jewel[0][0] <= b:
        heapq.heappush(tmp, -jewel[0][1])
        heapq.heappop(jewel)
    if tmp:
        result -= heapq.heappop(tmp)

print(result)

~~~


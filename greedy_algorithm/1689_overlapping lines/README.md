## 겹치는 선분

------

[1689번] 1차원 자표계 위에 선분 N개가 있다. 선분이 최대로 겹쳐있는 부분의 겹친 선분의 개수를 구해보자. 선분의 끝 점에서 겹치는 것은 겹치는 것으로 세지 않는다.

### 입력

- 첫째 줄에는 선분의 개수(1 ≤ N ≤ 1,000,000)가 입력으로 들어온다.
- 그 다음 N개의 줄에 선분의 시작 좌표 s와 끝나는 좌표 e(s < e)가 입력으로 들어온다. 선분의 좌표는 절댓값이 10억보다 작거나 같은 정수이다.

### 출력

- 첫째 줄에는 최대로 많이 겹치는 선분들의 개수를 출력한다.
------

### 풀이

해당 문제는 그리디 알고리즘과 비슷하면도 다른 방법을 기용한다. 바로 **"라인 스위핑" 알고리즘**을 사용한다.

#### 라인 스위핑(Sweepling Algorithm)?

직선 상에서 한쪽 시작점을 기준으로 반대편 종료지점까지 스캔하며 지나가는데, 이때 마주치는 요소들에 대한 **판단기준을 적용**하여 정답을 구하는 방법이다.

해당 문제를 풀이할 때, 처음에는 시작과 끝이 들어간 벡터값으로 선분들을 저장하여 풀이하려 하였다. 하지만 스위핑 알고리즘을 통해 더 쉽게 풀이가 가능하였다.
일단 시작과 끝점을 통한 선분으로 저장하는 것이 아니라 각 점으로 저장하는 것에서 시작한다.

선분이 시작점이라는 것은 겹치는 선분이 하나 늘어난다는 뜻이고 끝점이라는 뜻은 겹치는 선분이 하나 줄어든다는 뜻이다. 따라서 각 점을 저장할 때 시작점은 +1을 끝점은 -1을 부과하도록 저장한다.
이러한 점을 정렬하여 처음부터 끝까지 흩어보면 해당 지점에서 겹치는 선분이 몇개인지를 알 수 있다. 이를 최댓값으로 계속 비교하여 가장 많이 겹치는 경우를 구하면 된다.
~~~
import sys

points = []
n = int(input())
for _ in range(n):
    s, e = map(int, sys.stdin.readline().split())
    points.append((s, 1))
    points.append((e, -1))

points.sort()
result = 0
check = 0

for point in points:
    # 선이 시작 +1, 선이 끝나면 -1을 해준다.
    check += point[1]
    result = max(result, check)

print(result)

~~~

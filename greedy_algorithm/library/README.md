## 도서관

------

[1461번] 세준이는 도서관에서 일한다. 도서관의 개방시간이 끝나서 세준이는 사람들이 마구 놓은 책을 다시 가져다 놓아야 한다. 세준이는 현재 0에 있고, 사람들이 마구 놓은 책도 전부 0에 있다. 각 책들의 원래 위치가 주어질 때, 책을 모두 제자리에 놔둘때 드는 최소 걸음 수를 계산하는 프로그램을 작성하시오. 세준이는 한 걸음에 좌표 1칸씩 가며, 책의 원래 위치는 정수 좌표이다. 책을 모두 제자리에 놔둔 후에는 다시 0으로 돌아올 필요는 필요는 없다. 그리고 세준이는 한 번에 M권의 책을 들 수 있다. 

### 입력

- 첫째 줄에 책의 개수 N과, 세준이가 한 번에 들 수 있는 책의 개수 M이 주어진다.
- 둘째 줄에는 책의 위치가 주어진다. N과 M은 50보다 작거나 같은 자연수 이다.
- 책의 위치는 0이 아니며, 절댓값은 10,000보다 작거나 같은 정수이다.

### 출력

- 첫째 줄에 정답을 출력한다.

------

### 풀이

걸음 수가 적게 들기 위해서는 한번 특정 좌표로 이동할 때 그 사이에 있는 책의 위치를 모두 방문하는 것이 바람직하다. 물론 한번에 들 수 있는 책의 개수는 m개이므로 한 번에 m개의 책을 가져다 놓을 수 있는 만큼의 좌표를 가면 된다.  

여기서 걸음 수가 최소가 되기위해서 절댓값이 작은 수보다 큰 수를 기준으로 수들을 묶어야 한다.  
단, 음수에 위치한 책을 가져다 놓으면서 양수를 지나칠 수 없으므로 음수와 양수는 분리되어야 한다. 

마지막 책은 0으로 돌아올 필요가 없으므로 음수, 양수 중 가장 절댓값이 큰(가장 먼) 좌표를 한번 빼주면 된다.

~~~
n, m = map(int, input().split())
arr = list(map(int, input().split()))

arr_minus = [0]
arr_plus = [0]

for a in arr:
    if a < 0:
        arr_minus.append(a)
    else:
        arr_plus.append(a)
arr_minus.sort()
arr_plus.sort(reverse=True)

count = 0
i = 0

while i < len(arr_minus):
    count -= arr_minus[i]*2
    i += m
i = 0
while i < len(arr_plus):
    count += arr_plus[i]*2
    i += m
count -= max(abs(arr_minus[0]), abs(arr_plus[0]))
print(count)

~~~
